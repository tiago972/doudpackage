library(doudpackage)
setwd("/Users/Tiago/Desktop/BF\ is\ cool/nagisa")
source('./nagisa.R')
test<-ft_univ_tab(bdd, complete = TRUE, group="vivant.s4")
library(kableExtra)
total<-kable(test[,c("var", "level","Total", "0", "1","p")], "latex", booktabs = T, longtable=T, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
save_kable(total, "test.html")
save_kable(total, "test.jpg")
magick::read_image("../Judith Breth/Judith.pdf")
library(magick)
total<-kable(test[,c("var", "level","Total", "0", "1","p")], "latex", booktabs = T, longtable=T, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
magick::read_image("../Judith Breth/Judith.pdf")
save_kable(total, "test.jpg")
install.packages("magick")
install.packages("magick")
library(magick)
??read_image
install.packages("webshot")
install.packages("webshot")
webshot::install_phantomjs()
save_kable(total, "test.jpg")
library(kableExtra)
save_kable(total, "test.jpg")
library(magick)
magick::image_read("../Judith Breth/Judith.pdf")
save_kable(total, "test.jpg")
save_kable(total, "test.pdf")
setwd("/Users/Tiago/Desktop/BF\ is\ cool/nagisa")
source('./nagisa.R')
test<-ft_univ_tab(bdd, complete = TRUE, group="vivant.s4")
library(kableExtra)
total<-kable(test[,c("var", "level","Total", "0", "1","p")], "latex", booktabs = T, longtable=T, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
save_kable(total, "test.pdf")
library(doudpackage)
test<-ft_univ_tab(bdd, complete = TRUE, group="vivant.s4")
library(kableExtra)
total<-kable(test[,c("var", "level","Total", "0", "1","p")], "latex", booktabs = T, longtable=T, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
save_kable(total, "test.pdf")
save_kable(total, "test.pdf")
write_file(total, "test.tex")
setwd("/Users/Tiago/Desktop/BF\ is\ cool/nagisa")
source('./nagisa.R')
library(doudpackage)
test<-ft_univ_tab(bdd, complete = TRUE, group="vivant.s4")
library(kableExtra)
total<-kable(test[,c("var", "level","Total", "0", "1","p")], "latex", booktabs = T, longtable=T, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
save_kable(total, "test.html")
save_kable(total, "test.pdf", keep_tex = T)
?as_image
as_image(total)
as_image(total, file="test.png")
total<-kable(test[,c("var", "level","Total", "0", "1","p")], "latex", booktabs = T, longtable=T, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
as_image(total, file="test.png")
total<-kable(test[,c("var", "level","Total", "0", "1","p")], "latex", booktabs = T, longtable=T, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
as_image(total, file="test.png")
total<-kable(test[,c("var", "level","Total", "0", "1","p")], "latex", booktabs = T, longtable=T, caption = "Descriptive analysis", "html") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
save_kable(total, file="test.html")
help(package="magick")
install.packages("ImageMagick")
setwd("/Users/Tiago/Desktop/BF\ is\ cool/nagisa")
source('./nagisa.R')
library(doudpackage)
test<-ft_univ_tab(bdd, complete = TRUE, group="vivant.s4")
library(kableExtra)
total<-kable(test[,c("var", "level","Total", "0", "1","p")], format="latex",
booktabs = T, longtable=T, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
save_kable(total, "test.html", keep_tex = T)
save_kable(total, "test.html", keep_tex = T)
library(texPreview)
texPreview(total)
?texPreview
tex_preview(total)
tex_preview(total)
?tex_preview
total<-kable(test[,c("var", "level","Total", "0", "1","p")], format="latex",
booktabs = T, longtable=F, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
tex_preview(total)
save_kable(total, "test.pdf", kepp_tex=T)
save_kable(total, "test.pdf", kepp_tex=T)
save_kable(total, "test.pdf", keep_tex=T)
total<-kable(test[,c("var", "level","Total", "0", "1","p")], format="latex",
booktabs = T, longtable=F, caption = "Descriptive analysis") %>%
kable_styling(latex_options = c("striped", "repeat_header", "scale_down")) %>%
collapse_rows(columns = c(1, 6), latex_hline = "major", valign = "middle")
save_kable(total, "test.pdf", keep_tex=T)
tex_preview(total)
?fount_size
?font_sie
?font_size
?mfrow
?pa
?par
setwd("/Users/Tiago/Desktop/BF\ is\ cool/nagisa")
source('./nagisa.R')
library(doudpackage)
test<-ft_univ_tab(bdd, quanti = TRUE, group="vivant.s4", na.print = T)
test<-ft_univ_tab(bdd, quanti = TRUE, group="vivant.s4", na.print = F)
test<-ft_univ_tab(bdd, quanti = TRUE, group="vivant.s4", na.print = T)
#' Bivariate analysis
#'
#' Function that allows you to compute a p value according to a binary variable; default tests are Wilcoxon for quantitative variables, chisq or fisher wether chisq.test returns a warning
#' @param data A database, dataframe object
#' @param group Variable from which sub-groups are made to compute p values
#' @param signi Significance levels (def = 0.20)
#' @import stats
#' @import lubridate
#' @return Return a dataframe with univariate analaysis
#' @export
ft_ana_biv<-function(data, group, signi=0.20){
tmp<-as.data.frame(matrix(NA, ncol(data)-1, 4))
colnames(tmp)<-c("var", "test", "p", "signi")
options(warn=0)
my_env<-environment()
for (i in 1:ncol(data)){
if (colnames(data)[i]==group)
next;
if((is.numeric(data[,i])||is.integer(data[,i])) &&
(min(data[,i], na.rm = TRUE) != max(data[,i], na.rm = TRUE))){
tmp[i,"var"]<-colnames(data)[i]
tmp[i,"test"]<-"wilcoxon"
tmp[i,"p"]<-round(wilcox.test(data[,i]~data[,group])$p.value, digits = 7)
tmp[i, "signi"]<-ifelse(tmp[i,"p"]<signi,"OUI","non")
}else if (is.factor(data[,i]) && !is.Date(data[,i]) && nlevels(data[,i]) > 1){
tryCatch(
{
c<-c(chisq.test(data[,i], data[,group], correct=FALSE), test_name = "chi2")
},
warning=function(w){
my_env$c<-c(fisher.test(data[,i], data[,group], simulate.p.value = TRUE), test_name = "fisher")
},
finally = {
tmp[i,"var"]<-colnames(data)[i]
tmp[i,"test"]<-my_env$c$test_name
tmp[i,"p"]<-round(c$p.value,digits =7)
tmp[i, "signi"]<-ifelse(c$p.value<signi,"OUI","non")
})
} else
{
tmp[i,"var"]<-colnames(data)[i]
tmp[i,"test"]<-"not conformed to be tested"
tmp[i,"p"]<-NA
tmp[i, "signi"]<-NA
}
}
tmp<-tmp[complete.cases(tmp$var),]
return (tmp)
}
#### Fonction annexe pour renommer la var contene dans biv comme celles du dataframe de sortie ###
ft_rename_quanti_biv<-function(biv, na.print)
{
if (!isTRUE(na.print))
{
for (i in 1:nrow(biv))
biv[i,1]<-paste(biv[i,1], "(median(IQR))", sep = " ")
}
else if (isTRUE(na.print))
{
for (i in 1:nrow(biv))
biv[i,1]<-paste(biv[i,1], "(median(IQR); NAs(%))", sep = " ")
}
return(biv)
}
#### Fonction principale pour les differents elements de l analyse univariee ####
ft_tab_quanti<-function(data, i, group=NULL, group_level=NULL)
{
if (!is.null(group))
subset<-data[which(data[,group]==group_level),]
else
subset<-data
"Min"<-round(min(subset[,i], na.rm=TRUE), 1)
"Max"<-round(max(subset[,i], na.rm=TRUE), 1)
"mediane"<-round(quantile(subset[,i], probs = seq(0,1,0.5),na.rm=TRUE)[2], 1)
"first_quartile"<-round(quantile(subset[,i], probs = seq(0,1,0.25),na.rm=TRUE)[2], 1)
"third_quartile"<-round(quantile(subset[,i], probs = seq(0,1,0.25),na.rm=TRUE)[4], 1)
"prop_NAs"<-ifelse(is.na(table(is.na(subset[,i]))[2]), 0, round(prop.table(table(is.na(subset[,i])))[2] * 100, digits = 2))
"NNAs"<-ifelse(is.na(table(is.na(subset[,i]))[2]), 0,table(is.na(subset[,i]))[2])
tmp_mat<-c(var = colnames(data)[i], "Min-Max"=paste(Min, Max, sep="-"),
"median(IQR)"=gsub(" ", "", paste(mediane, "(", first_quartile, "-", third_quartile, ")")),
NAs=gsub(" ", "", paste(NNAs, "(", prop_NAs, ")")))
return(tmp_mat)
}
#### Fonction pour le filtrage des elements selon les options choisies ####
ft_parse_quanti_opt<-function(data, min.max, na.print, group)
{
if (!isTRUE(min.max))
data<-data[,!names(data) %in% "Min-Max"]
if (!isTRUE(na.print))
{
data<-data[,!names(data) %in% "NAs"]
print("bug")
for (i in 1:nrow(data))
data[i,1]<-paste(data[i,1], "(median(IQR))", sep = " ")
}
else if (isTRUE(na.print) && !is.null(group))
{
data[,'median(IQR)']<-paste(data[,'median(IQR)'], data[,'NAs'], sep = "; ")
data<-data[,!names(data) %in% "NAs"]
for (i in 1:nrow(data))
data[i,1]<-paste(data[i,1], "(median(IQR); NAs(%))", sep = " ")
}
return(data)
}
#### si pvalue est true #####
#' @import tidyr
ft_univ_quanti_p.value<-function(data, group, min.max, na.print,tab_tmp)
{
dicho<-ft_parse_quanti_opt(tab_tmp, min.max, na.print, group)
total<-ft_quanti(data, NULL, NULL, min.max, na.print)
biv<-ft_ana_biv(data, group)
total$Group <- "Total"
total<-merge(total, dicho, all=TRUE)
biv<-ft_rename_quanti_biv(biv, na.print)
total<-merge(total, biv, all.x=TRUE)
total<-total[,!names(total) %in% c("test", "signi")]
if (isTRUE(min.max))
total<-pivot_wider(total, names_from = "Group", values_from = c("median(IQR)", "Min-Max"))
else
total<-pivot_wider(total, names_from = "Group", values_from = c("median(IQR)"))
total$p<-ifelse(as.numeric(total$p) < 0.001, "< .001", round(as.numeric(total$p), digits = 3))
return(total)
}
### simple fonction coupee ####
ft_univ_quanti_2<-function(data, group, p.value, min.max, na.print){
tab_1<-data.frame("var"=NA, "Min-Max"=NA, "median(IQR)"=NA, "NAs"=NA)
colnames(tab_1)=c("var", "Min-Max", "median(IQR)", "NAs")
tab_2<-data.frame("var"=NA, "Min-Max"=NA, "median(IQR)"=NA, "NAs"=NA)
colnames(tab_2)=c("var", "Min-Max", "median(IQR)", "NAs")
j = 0;
for (i in 1:ncol(data))
{
if (colnames(data)[i]==group || !is.numeric(data[,i]))
next ;
j = j + 1
tmp_1<-ft_tab_quanti(data, i, group, levels(data[,group])[1])
tmp_2<-ft_tab_quanti(data, i, group, levels(data[,group])[2])
for (k in 1:4)
tab_1[j,k]<-tmp_1[k]
for (k in 1:4)
tab_2[j,k]<-tmp_2[k]
}
tab_1$Group=levels(data[,group])[1]
tab_2$Group=levels(data[,group])[2]
tmp<-merge(tab_1, tab_2, all=TRUE)
if (!isTRUE(p.value))
{
tmp<-ft_parse_quanti_opt(tmp, min.max, na.print, group)
if (!isTRUE(min.max))
tmp<-pivot_wider(tmp, names_from = "Group", values_from = "median(IQR)")
else
tmp<-pivot_wider(tmp, names_from = "Group", values_from = c("median(IQR)", "Min-Max"))
return (tmp)
}
else
return (ft_univ_quanti_p.value(data, group, min.max, na.print,tmp))
}
ft_quanti<-function(data, group=NULL, p.value, min.max, na.print){
if (is.null(group))
{
tab<-data.frame("var"=NA, "Min-Max"=NA, "median(IQR)"=NA, "NAs"=NA)
colnames(tab)=c("var", "Min-Max", "median(IQR)", "NAs")
j = 0
for (i in 1:ncol(data))
{
if (!is.numeric(data[,i]))
next;
j = j + 1
tmp<-ft_tab_quanti(data,i)
for (k in 1:4)
tab[j,k]<-tmp[k]
}
tab<-ft_parse_quanti_opt(tab, min.max, na.print, NULL)
return(tab)
}
else
return(ft_univ_quanti_2(data, group, p.value, min.max, na.print))
}
detach("package:doudpackage", unload = T)
# library(doudpackage)
test<-ft_univ_tab(bdd, quanti = TRUE, group="vivant.s4", na.print = T)
#### Il rajouter l option parsed
### Mettre le n total de chaque groupe dans le titre
#' Generic function to create a table of descriptive analysis of a dataset
#'
#' This function allows you to display all together all univariate analysis (min-max; median; IQR; proportions) and bivariates analysis (wilcoxon, chisq or fisher). The univariate analysis can be sub-grouped by a viariable of interest (binary variable)
#' @param data A dataset, needs to be a dataframe object
#' @param group The variable of interest for you univariate analylisis to sub-grouped by.
#' @param complete Wether to print quantitative and qualitative variables; default = TRUE
#' @param quanti To be used only if complete is FALSE. If TRUE, returns only the univariate analysis for quantitative variables
#' @param quali To be used only if complete is FALSE. If TRUE returns only the univariate analysis for qualitative variables
#' @param na.print Wether to print NAs n(%), default = FALSE. Note that if true, "Total" will also be printed. This will be change in a futur version
#' @param p.value Print p value. Group needs to be set; default = TRUE. If TRUE, "Total" will also be printed
#' @param min.max Display min and max value for quantitative variables; default is false
#' @param digits.opt How many numbers after the "." you'd like for the proportions of qualitative variables; default is 0
#' @return The object returned depends on the "parse" option:either a dataframe or a kable oject
#' @export
ft_univ_tab<-function(data, group=NULL, complete = TRUE, quanti=FALSE, quali=FALSE, na.print = FALSE, p.value=TRUE, min.max=FALSE, digits.opt=0){
if (!is.null(group) && (!is.factor(data[,group]) || nlevels(data[,group]) > 3))
{
write("Grouping error dude, check if the variable is a binary factor", stderr())
return (-1)
}
if (isTRUE(quanti)||isTRUE(quali))
complete=FALSE
if (isTRUE(complete) || isTRUE(quanti))
quanti_tab<-ft_quanti(data, group, p.value, min.max, na.print)
if (isTRUE(complete) || isTRUE(quali))
quali_tab<-ft_quali(data, group, p.value, na.print, digits.opt)
if (!isTRUE(complete) && isTRUE(quanti))
return(quanti_tab)
else if (!isTRUE(complete) && isTRUE(quali))
return(quali_tab)
res<-merge(quanti_tab, quali_tab, all=TRUE)
return (res)
}
# library(doudpackage)
test<-ft_univ_tab(bdd, quanti = TRUE, group="vivant.s4", na.print = T)
# library(doudpackage)
test<-ft_univ_tab(bdd, quanti = TRUE, group="vivant.s4", na.print = T)
View(test)
# library(doudpackage)
test<-ft_univ_tab(bdd, quali = TRUE, group="vivant.s4", na.print = T)
ft_parse_quali_opt<-function(tmp, opt, v_group=NULL, na.print)
{
if (opt == 1)
{
tmp[,"n(%)"]<-paste(tmp$n, "(", tmp[,"%"], ")", sep="")
tmp[,"NAs(%)"]<-paste(tmp[,"NAs"], "(", tmp[,"%_NAs"], ")", sep = "")
tmp<-tmp[,!names(tmp) %in% c("n", '%', "NAs", "%_NAs")]
if (isFALSE(na.print))
{
tmp<-tmp[,!names(tmp) %in% "NAs(%)"]
for (i in 1:nrow(tmp))
tmp[i,1]<-paste(tmp[i,1], "n(%)", sep = " ")
}
else
{
for (i in 1:nrow(tmp))
tmp[i,1]<-paste(tmp[i,1], "(n(%);NAs(%))", sep = " ")
tmp[,"n(%)"]<-paste(tmp[,"n(%)"], tmp[,"NAs(%)"], sep=";")
tmp<-tmp[,!names(tmp) %in% "NAs(%)"]
}
}
else if (opt == 2)
colnames(tmp)[colnames(tmp)=="n(%)"]<-"Total"
else if (opt == 3)
{
if (isFALSE(na.print))
{
tmp<-tmp[,!names(tmp) %in% "NAs(%)"]
for (i in 1:nrow(tmp))
tmp[i,1]<-paste(tmp[i,1], "n(%)", sep = " ")
}
else
{
for (i in 1:nrow(tmp))
tmp[i,1]<-paste(tmp[i,1], "(n(%);NAs(%))", sep = " ")
}
}
return (tmp)
}
ft_quali.pvalue<-function(data, res, group, na.print, digits.opt){
v_group<-c(levels(data[,group]))
res_tot<-ft_parse_quali_opt(ft_quali(data, NULL, NULL, na.print, digits.opt), 2, NULL, na.print)
res<-merge(res, res_tot, all=TRUE)
p<-ft_parse_quali_opt(ft_ana_biv(data, group), 3, NULL, na.print)
p<-p[,!names(p) %in% c("signi", "test")]
p$p<-ifelse(as.numeric(p$p) < 0.001, '<.001', round(as.numeric(p$p), digits=3))
res<-merge(res, p, all.x=TRUE)
return(res)
}
#' @import tidyr
ft_quali_grouped<-function(data, group, p.value, na.print, digits.opt)
{
tmp_1<-data[which(data[,group]==levels(data[,group])[1]),]
tmp_1<-tmp_1[,-which(colnames(tmp_1)==group)]
tmp_1<-ft_quali(tmp_1, group=NULL, p.value, na.print, digits.opt)
tmp_1$Group=levels(data[,group])[1]
tmp_2<-data[which(data[,group]==levels(data[,group])[2]),]
tmp_2<-tmp_2[,-which(colnames(tmp_2)==group)]
tmp_2<-ft_quali(tmp_2, group=NULL, p.value, na.print, digits.opt)
tmp_2$Group=levels(data[,group])[2]
res<-merge(tmp_1, tmp_2, all=TRUE)
res<-pivot_wider(res, names_from = "Group", values_from =  "n(%)")
if (isFALSE(p.value))
return(res)
else
return (ft_quali.pvalue(data, res, group, na.print, digits.opt))
}
ft_quali<-function(data, group=NULL, p.value, na.print, digits.opt){
if (is.null(group))
{
j <- 0;
tmp<-as.data.frame(matrix(NA, 1, 6))
colnames(tmp)<-c("var", "level", "n", "%", "NAs", "%_NAs")
for (i in 1:ncol(data))
{
if (!is.factor(data[,i]) || nlevels(data[,i]==1))
next;
for (k in 1:nlevels(data[,i]))
{
tmp[j + k, "var"]<-colnames(data)[i]
tmp[j + k, "level"]<-levels(data[,i])[k]
tmp[j + k, "n"]<-table(data[,i])[k]
tmp[j + k, "%"]<-round(prop.table(table(data[,i], useNA = "always"))[k] * 100, digits = digits.opt)
tmp[j + k, "NAs"]<-table(data[,i], useNA = "always")[nlevels(data[,i]) + 1]
tmp[j + k, "%_NAs"]<-round(prop.table(table(data[,i], useNA = "always"))[nlevels(data[,i]) + 1] * 100, digits = digits.opt)
if (k == nlevels(data[,i]))
j = j + k
}
}
tmp = ft_parse_quali_opt(tmp, 1, group, na.print)
return (tmp)
}
else
return (ft_quali_grouped(data, group, p.value, na.print, digits.opt))
}
# library(doudpackage)
test<-ft_univ_tab(bdd, quali = TRUE, group="vivant.s4", na.print = T)
View(test)
# library(doudpackage)
test<-ft_univ_tab(bdd, quanti = TRUE, group="vivant.s4", na.print = T)
View(test)
# library(doudpackage)
test<-ft_univ_tab(bdd, quanti = TRUE, group="vivant.s4", na.print = T, p.value = F)
View(test)
# library(doudpackage)
test<-ft_univ_tab(bdd, quali = TRUE, group="vivant.s4", na.print = T, p.value = F)
View(test)
# library(doudpackage)
test<-ft_univ_tab(bdd, group="vivant.s4", na.print = T, p.value = F)
View(test)
