---
title: "tmp"
author: "Edouard Baudouin"
date: "06/02/2021"
output: html_document
---
```{r, echo=F, message=F}
#### Fonction principale pour les differents elements de l analyse univariee ####
ft_tab_quanti<-function(data, i, group=NULL, group_level=NULL, digits.opt)
{
  if (!is.null(group))
    subset<-data[which(data[,group]==group_level),]
  else
    subset<-data
  "Min"<-min(subset[,i], na.rm=TRUE)
  "Max"<-max(subset[,i], na.rm=TRUE)
  "mean"<-round(mean(subset[,i], na.rm = T), digits = digits.opt)
  "sd"<-round(sd(subset[,i], na.rm = T), digits = digits.opt)
  "prop_NAs"<-ifelse(is.na(table(is.na(subset[,i]))[2]), 0, round(prop.table(table(is.na(subset[,i])))[2] * 100, digits = digits.opt))
  "NNAs"<-ifelse(is.na(table(is.na(subset[,i]))[2]), 0,table(is.na(subset[,i]))[2])
  tmp_mat<-c(var = colnames(data)[i],
             "Total"=gsub(" ", "", paste(mean, "(",  sd,")")), "Min-Max"=paste(Min, Max, sep="-"))
  tmp_NA <-c("Missing values, n(%)", gsub(" ", "", paste(NNAs, "(", prop_NAs, ")")),
             gsub(" ", "", paste(NNAs, "(", prop_NAs, ")")))
    tmp_mat<-rbind(tmp_mat, tmp_NA)
    rownames(tmp_mat)<-NULL
  return(tmp_mat)
}

#### si pvalue est true #####
#' @import tidyr
#' @import plyr
ft_univ_quanti_p.value<-function(data, group, min.max, na.print,tab_tmp, digits.opt)
{
  total<-ft_quanti(data, NULL, NULL, min.max, na.print, digits.opt)
  biv<-ft_ana_biv(data, group)
  total$Group <- "Total"
  total<-ft_merge_tot(tab_tmp, total)
  biv<-biv[biv$var %in% total$var,]
  biv<-biv[,!names(biv) %in% c("test", "signi")]
  total<-plyr::join(total, biv, by = "var")
  return(total)
}

### simple fonction coupee ####
ft_univ_quanti_2<-function(data, group, p.value, min.max, na.print, digits.opt){
  tab_1<-data.frame("var"=NA, "Total"=NA, "Min-Max"=NA)
  colnames(tab_1)=c("var", "Total", "Min-Max")
  tab_2<-data.frame("var"=NA, "Total"=NA, "Min-Max"=NA)
  colnames(tab_2)=c("var", "Total", "Min-Max")
  j = 1;
  tab_1<-c()
  tab_2<-c()
  for (i in 1:ncol(data))
  {
    if (colnames(data)[i]==group || !is.numeric(data[,i]))
      next ;
    tmp_1<-ft_tab_quanti(data, i, group, levels(data[,group])[1], digits.opt)
    tmp_2<-ft_tab_quanti(data, i, group, levels(data[,group])[2], digits.opt)
    tab_1<-as.data.frame(rbind(tab_1, tmp_1))
    tab_2<-as.data.frame(rbind(tab_2, tmp_2))
  }
  tab_1$Group=levels(data[,group])[1]
  tab_2$Group=levels(data[,group])[2]
  tmp<-ft_merge(tab_1, tab_2)
  if (!isTRUE(p.value))
  {
    tmp<-ft_parse_quanti_opt(tmp, min.max, na.print, group)
    if (!isTRUE(min.max))
      tmp<-pivot_wider(tmp, names_from = "Group", values_from = "Total")
    else
      tmp<-pivot_wider(tmp, names_from = "Group", values_from = c("Total", "Min-Max"))
    return (tmp)
  }
  else
    return (ft_univ_quanti_p.value(data, group, min.max, na.print,tmp, digits.opt))
}

ft_quanti<-function(data, group=NULL, p.value, min.max, na.print, digits.opt){
  if (is.null(group))
  {
    tab<-data.frame("var"=NA, "Total"=NA, "Min-Max"=NA)
    colnames(tab)=c("var", "Total", "Min-Max")
    j = 1
    for (i in 1:ncol(data))
    {
      if (!is.numeric(data[,i]))
        next;
      tmp<-ft_tab_quanti(data,i, NULL, NULL, digits.opt)
      for (k in 1:3)
      {
        tab[j,k]<-tmp[1,k]
        tab[j+1,k]<-tmp[2,k]
      }
      j = j + 2
    }
    return(tab)
  }
  else
    return(ft_univ_quanti_2(data, group, p.value, min.max, na.print, digits.opt))
}
######## il faut faire une ft_error #####
#### Il rajouter l option parsed
### Mettre le n(%) de chaque groupe dans le titre
## Il faut rajouter la possibilite d'avoir ou SD ou l'IQR
## Il faut changer l'affichage en mettant les Nas en dessous si il y en a et lvl dans le nom de var
## Il faut rajouter les anova si groupe à > 2 classes; ça implique de revoir les remplissage des tableaux selon la modalité de groupe

#' Generic function to create a table of descriptive analysis of a dataset
#'
#' This function allows you to display all together all univariate analysis (min-max; median; IQR; proportions) and bivariates analysis (wilcoxon, chisq or fisher). The univariate analysis can be sub-grouped by a viariable of interest (binary variable)
#' @param data A dataset, needs to be a dataframe object
#' @param group The variable of interest for you univariate analysis to sub-grouped by.
#' @param complete Wether to print quantitative and qualitative variables; default = TRUE
#' @param quanti To be used only if complete is FALSE. If TRUE, returns only the univariate analysis for quantitative variables
#' @param quali To be used only if complete is FALSE. If TRUE returns only the univariate analysis for qualitative variables
#' @param na.print Wether to print NAs n(%), default = FALSE. Note that if true, "Total" will also be printed. This will be change in a futur version
#' @param p.value Print p value. Group needs to be set; default = TRUE. If TRUE, "Total" will also be printed
#' @param min.max Display min and max value for quantitative variables; default is false
#' @param digits.opt How many numbers after the "." you'd like for the proportions of qualitative variables; default is 0
#' @return The object returned depends on the "parse" option:either a dataframe or a kable oject
#' @export
ft_desc_tab<-function(data, group=NULL, complete = TRUE, quanti=FALSE, quali=FALSE, na.print = FALSE, p.value=TRUE, min.max=FALSE, digits.opt=0){
  if (!is.null(group) && (!is.factor(data[,group]) || nlevels(data[,group]) > 3))
  {
    write("Grouping error dude, check if the variable is a binary factor", stderr())
    return (-1)
  }
  if (isFALSE(complete) && isFALSE(quanti) && isFALSE(quali))
  {
    write("Error, if complete is FALSE, quanti or quali must be TRUE", stderr())
    return(-1)
  }
  if (isTRUE(quanti)||isTRUE(quali))
    complete=FALSE
  if (isTRUE(complete) || isTRUE(quanti))
  {
    quanti_tab<-ft_parse_quanti_opt(ft_quanti(data, group, p.value, min.max, na.print, digits.opt), min.max, na.print)
    if (isTRUE(min.max))
      quanti_tab<-pivot_wider(quanti_tab, names_from = "Group", values_from = c("Total", "Min-Max"))
    else
      quanti_tab<-pivot_wider(quanti_tab, names_from = "Group", values_from = c("Total"))
  }
   if (isTRUE(complete) || isTRUE(quali))
     quali_tab<-ft_quali(data, group, p.value, na.print, digits.opt)
  if (!isTRUE(complete) && isTRUE(quanti))
    return(quanti_tab)
  else if (!isTRUE(complete) && isTRUE(quali))
    return(quali_tab)
  res<-merge(quanti_tab, quali_tab, all=TRUE)
  return (res)
}
### Remove all corresponding NA lines if there are no NA in total group
ft_remove_null_na<-function(data)
{
  i = 1;
  tmp<-c();
  while (i <= nrow(data))
  {
    if ((i + 5) <= nrow(data) && grepl(pattern = "0(0)", data[(i+5), "Total"], fixed = T))
      tmp2<-rbind(data[i,], data[(i+2),], data[(i+4),])
    else
      tmp2<-rbind(data[i:(i+5),])
    i = i + 6
    tmp<-rbind(tmp, tmp2)
  }
  return(tmp)
}

#### Fonction pour le filtrage des elements selon les options choisies ####
ft_parse_quanti_opt<-function(data, min.max, na.print)
{
  i = 1;
  while (i <= nrow(data))
  {
    data[i,1]<-paste(data[i,1], ", mean(SD)", sep = "")
    i = i + 2;
  }
  if (!isTRUE(min.max))
    data<-data[,!names(data) %in% "Min-Max"]
  if (!isTRUE(na.print))
    data<-data[!grepl("Missing Values n(%)", data[,"var"], fixed = T),]
  else
    data<-ft_remove_null_na(data)
  return(data)
}

## iterates rbind to conserve row order for merging
ft_merge<-function(tab_1, tab_2)
{
  i = 1;
  tmp<-c()
  while ((i + 1) <= nrow(tab_1))
  {
    tmp2<-rbind(tab_1[i:(i+1),], tab_2[i:(i+1),])
    tmp<-rbind(tmp, tmp2)
    i = i + 2;
  }
  return(tmp)
}

ft_merge_tot<-function(tab_1, tab_2)
{
  i = 1;
  j = 1;
  tmp<-c()
  while ((i + 3) <= nrow(tab_1))
  {
    tmp2<-rbind(tab_1[i:(i+3),], tab_2[j:(j+1),])
    tmp<-rbind(tmp, tmp2)
    i = i + 4;
    j = j + 2;
  }
  return(tmp)
}
#' Bivariate analysis
#'
#' Function that allows you to compute a p value according to a binary variable; default tests are Wilcoxon for quantitative variables, chisq or fisher wether chisq.test returns a warning
#' @param data A database, dataframe object
#' @param group Variable from which sub-groups are made to compute p values
#' @param signi Significance levels (def = 0.20)
#' @import stats
#' @import lubridate
#' @return Return a dataframe with univariate analaysis
#' @export
ft_ana_biv<-function(data, group, signi=3){
  tmp<-as.data.frame(matrix(NA, ncol(data)-1, 3))
  colnames(tmp)<-c("var", "test", "p")
  options(warn=0)
  my_env<-environment()
  for (i in 1:ncol(data)){
    if (colnames(data)[i]==group)
      next;
    if((is.numeric(data[,i])||is.integer(data[,i])) &&
       (min(data[,i], na.rm = TRUE) != max(data[,i], na.rm = TRUE))){
      tmp[i,"var"]<-colnames(data)[i]
      tmp[i,"test"]<-"t.test"
      t<-t.test(data[,i]~data[,group])$p.value
      if (t < 0.001)
        tmp[i,"p"]<-"< .001"
      else
        tmp[i,"p"]<-round(t, digits = signi)
    }else if (is.factor(data[,i]) && !is.Date(data[,i]) && nlevels(data[,i]) > 1){
      tryCatch(
        {
          c<-c(chisq.test(data[,i], data[,group], correct=FALSE), test_name = "chi2")
        },
        warning=function(w){
          my_env$c<-c(fisher.test(data[,i], data[,group], simulate.p.value = TRUE), test_name = "fisher")
        },
        finally = {
          tmp[i,"var"]<-colnames(data)[i]
          tmp[i,"test"]<-my_env$c$test_name
          if (c$p.value < 0.001)
            tmp[i,"p"]<-"< .001"
          else
            tmp[i,"p"]<-round(c$p.value,digits = signi)
        })
    } else
    {
      tmp[i,"var"]<-colnames(data)[i]
      tmp[i,"test"]<-"not conformed to be tested"
      tmp[i,"p"]<-NA
      tmp[i, "signi"]<-NA
    }
  }
  tmp<-tmp[complete.cases(tmp$var),]
  return (tmp)
}

```

```{r, echo=F}
setwd("/Users/Tiago/Desktop/BF\ is\ cool/nagisa")
source('./nagisa.R')
# library(doudpackage)
test3<-ft_desc_tab(bdd, complete = F, quanti = T, na.print = T, p.value = T, group="vivant.s4")

library(kableExtra)
colnames(test3)<-c("" ,"p", "n = 34(34%)", "n = 64%", "n = 100")
total<-kable(test3[c("", "n = 100", "n = 64%", "n = 34(34%)", "p")]) %>% 
  kable_classic(full_width = F) %>%
  add_header_above(c(" ", "Total" = 1, "Deceased" = 1, "Survivor" = 1, " ")) %>%
  add_indent(9)

  total
```

```{r, echo=F}
library(htmlTable)
test3<-as.data.frame(test3)
nom<-test3[,1]
rownames(test3)<-nom
total<-htmlTable(test3[c("n = 100", "n = 64%", "n = 34(34%)", "p")],
                 cgroup = c("Total","Deceased", "Survivor", ""), n.cgroup = c(1, 1, 1, 1))
total

```

